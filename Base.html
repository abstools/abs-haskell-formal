<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Base</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Base.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Base.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">abs-haskell-formal-0.0.1: Translating ABS to Haskell to prove correctness &amp; resource consumption</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Base</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The values of our language</a></li><li><a href="#g:2">The datastructures used at ABS-runtime</a></li><li><a href="#g:3">Our language's AST and types</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The ABS' AST and the ABS-runtime data-structures</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Ref">Ref</a> = <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:ObjRef">ObjRef</a> = <a href="Base.html#t:Ref">Ref</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:FutRef">FutRef</a> = <a href="Base.html#t:Ref">Ref</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Counter">Counter</a> = <a href="Base.html#t:Ref">Ref</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Heap">Heap</a> = <a href="#v:Heap">Heap</a> {<ul class="subs"><li><a href="#v:objects">objects</a> :: <a href="Base.html#t:Objects">Objects</a></li><li><a href="#v:futures">futures</a> :: <a href="Base.html#t:Futures">Futures</a></li><li><a href="#v:newRef">newRef</a> :: <a href="Base.html#t:Counter">Counter</a></li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:Objects">Objects</a> = IOVector (<a href="Base.html#t:Attrs">Attrs</a>, <a href="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html#t:Seq">Seq</a> <a href="Base.html#t:Proc">Proc</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Attrs">Attrs</a> = IOVector <a href="Base.html#t:Ref">Ref</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Futures">Futures</a> = IOVector (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either">Either</a> [<a href="Base.html#t:ObjRef">ObjRef</a>] <a href="Base.html#t:Ref">Ref</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Cont">Cont</a> = <a href="Base.html#t:Stmt">Stmt</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Proc">Proc</a> = <a href="#v:Proc">Proc</a> {<ul class="subs"><li><a href="#v:fromProc">fromProc</a> :: (<a href="Base.html#t:FutRef">FutRef</a>, <a href="Base.html#t:Cont">Cont</a>)</li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:SchedQueue">SchedQueue</a> = Q <a href="Base.html#t:ObjRef">ObjRef</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Stmt">Stmt</a><ul class="subs"><li>= <a href="#v:Assign">Assign</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> <a href="Base.html#t:Rhs">Rhs</a> <a href="Base.html#t:Cont">Cont</a></li><li>| <a href="#v:Await">Await</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> <a href="Base.html#t:Cont">Cont</a></li><li>| <a href="#v:If">If</a> <a href="Base.html#t:BExp">BExp</a> (<a href="Base.html#t:Cont">Cont</a> -&gt; <a href="Base.html#t:Stmt">Stmt</a>) (<a href="Base.html#t:Cont">Cont</a> -&gt; <a href="Base.html#t:Stmt">Stmt</a>) <a href="Base.html#t:Cont">Cont</a></li><li>| <a href="#v:While">While</a> <a href="Base.html#t:BExp">BExp</a> (<a href="Base.html#t:Cont">Cont</a> -&gt; <a href="Base.html#t:Stmt">Stmt</a>) <a href="Base.html#t:Cont">Cont</a></li><li>| <a href="#v:Skip">Skip</a> <a href="Base.html#t:Cont">Cont</a></li><li>| <a href="#v:Return">Return</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a>) <a href="Base.html#t:Cont">Cont</a></li><li>| <a href="#v:GetBlocked">GetBlocked</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Rhs">Rhs</a><ul class="subs"><li>= <a href="#v:New">New</a></li><li>| <a href="#v:Get">Get</a> <a href="Base.html#t:FutRef">FutRef</a></li><li>| <a href="#v:Async">Async</a> <a href="Base.html#t:ObjRef">ObjRef</a> <a href="Base.html#t:Method">Method</a> [<a href="Base.html#t:Ref">Ref</a>]</li><li>| <a href="#v:Sync">Sync</a> <a href="Base.html#t:Method">Method</a> [<a href="Base.html#t:Ref">Ref</a>]</li><li>| <a href="#v:Val">Val</a> <a href="Base.html#t:V">V</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:V">V</a><ul class="subs"><li>= <a href="#v:I">I</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li><li>| <a href="#v:Add">Add</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:Sub">Sub</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:Prod">Prod</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:Div">Div</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:Mod">Mod</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:Attr">Attr</a> <a href="Base.html#t:Ref">Ref</a></li><li>| <a href="#v:Param">Param</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:BExp">BExp</a><ul class="subs"><li>= <a href="#v:BEq">BEq</a> <a href="Base.html#t:Ref">Ref</a> <a href="Base.html#t:Ref">Ref</a></li><li>| <a href="#v:BNeg">BNeg</a> <a href="Base.html#t:BExp">BExp</a></li><li>| <a href="#v:BCon">BCon</a> <a href="Base.html#t:BExp">BExp</a> <a href="Base.html#t:BExp">BExp</a></li><li>| <a href="#v:BDis">BDis</a> <a href="Base.html#t:BExp">BExp</a> <a href="Base.html#t:BExp">BExp</a></li><li>| <a href="#v:IEq">IEq</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:INEq">INEq</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:IGT">IGT</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:IGTE">IGTE</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:ILT">ILT</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li><li>| <a href="#v:ILTE">ILTE</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Method">Method</a> = [<a href="Base.html#t:Ref">Ref</a>] -&gt; <a href="Base.html#t:ObjRef">ObjRef</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Base.html#t:Ref">Ref</a> -&gt; <a href="Base.html#t:Cont">Cont</a> -&gt; <a href="Base.html#t:Cont">Cont</a></li></ul></div><div id="interface"><h1 id="g:1">The values of our language</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Ref" class="def">Ref</a> = <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> <a href="src/Base.html#Ref" class="link">Source</a></p><div class="doc"><p>We only have one type for our values: the <code><a href="Base.html#t:Ref">Ref</a></code>erence. Both objects and future values have type <code><a href="Base.html#t:Ref">Ref</a></code>.</p><p>NB: This ABS-subset is dynamically-typed, so it will probably to errors
 if an object is expected but a future is passed, and vice-versa.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:ObjRef" class="def">ObjRef</a> = <a href="Base.html#t:Ref">Ref</a> <a href="src/Base.html#ObjRef" class="link">Source</a></p><div class="doc"><p>An object value is a reference (index) to the object heap</p><p>note: type synonym for clarity</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:FutRef" class="def">FutRef</a> = <a href="Base.html#t:Ref">Ref</a> <a href="src/Base.html#FutRef" class="link">Source</a></p><div class="doc"><p>A future value is a reference (index) to the future heap</p><p>(note: type synonym for clarity)</p></div></div><h1 id="g:2">The datastructures used at ABS-runtime</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Counter" class="def">Counter</a> = <a href="Base.html#t:Ref">Ref</a> <a href="src/Base.html#Counter" class="link">Source</a></p><div class="doc"><p>An ever-increasing memory-counter to pick new unique references when
 creating new objects (via new) and futures (via async)</p><p>(note: type synonym for making the translation clear)</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Heap" class="def">Heap</a> <a href="src/Base.html#Heap" class="link">Source</a></p><div class="doc"><p>the simulated Heap datastructure where all objects&amp;futurues live in.</p><p>NB: assume no Garbage-Collection of the Heap for the moment. At runtime,
 no GC will be performed from the underlying Haskell-GC, because we do not delete objects.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Heap" class="def">Heap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:objects" class="def">objects</a> :: <a href="Base.html#t:Objects">Objects</a></dt><dd class="doc"><p>all the objects</p></dd><dt class="src"><a name="v:futures" class="def">futures</a> :: <a href="Base.html#t:Futures">Futures</a></dt><dd class="doc"><p>all the futures</p></dd><dt class="src"><a name="v:newRef" class="def">newRef</a> :: <a href="Base.html#t:Counter">Counter</a></dt><dd class="doc"><p>the current counter</p></dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Objects" class="def">Objects</a> = IOVector (<a href="Base.html#t:Attrs">Attrs</a>, <a href="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html#t:Seq">Seq</a> <a href="Base.html#t:Proc">Proc</a>) <a href="src/Base.html#Objects" class="link">Source</a></p><div class="doc"><p>The objects of the heap is a <strong>growable</strong> 0-int-indexed array where each cell is a pair of the object's attributes and the object's process queue</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Attrs" class="def">Attrs</a> = IOVector <a href="Base.html#t:Ref">Ref</a> <a href="src/Base.html#Attrs" class="link">Source</a></p><div class="doc"><p>The attributes is a <strong>fixed</strong> array of attribute names (Ints) to attribute values (<code><a href="Base.html#t:Ref">Ref</a></code>s)</p><p>We assume a preprocessing step to transform <strong>all</strong> the attribute names occuring in a program to Ints so they can become the indices to this array.
 NB: All objects have the same fixed size attr-array, although they may only use a subset of all the attributes.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Futures" class="def">Futures</a> = IOVector (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either">Either</a> [<a href="Base.html#t:ObjRef">ObjRef</a>] <a href="Base.html#t:Ref">Ref</a>) <a href="src/Base.html#Futures" class="link">Source</a></p><div class="doc"><p>The futures of the heap is a <strong>growable</strong> int-indexed array of the futures' potential final values.</p><p>A future is empty (<code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#v:Left">Left</a></code>), with n callers waiting on it. 
 A future is resolved (filled with 'Right value'), hence its type &quot;Either [ObjRef] Ref&quot;.</p><p>NB: The correctness and preservation assume ABS programs with only 1 waiting-caller, in other words
 programs that do not pass-over a created future to another object.</p><p>A future reference must be _final_ after resolved, and this must be guaranteed by the runtime system.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Cont" class="def">Cont</a> = <a href="Base.html#t:Stmt">Stmt</a> <a href="src/Base.html#Cont" class="link">Source</a></p><div class="doc"><p>We have a single (universal) type for our continuations. 
 Later, if we introduce local-variables we are going to need an extra type for Continuations: 'Ref -&gt; Stmt'</p></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Proc" class="def">Proc</a> <a href="src/Base.html#Proc" class="link">Source</a></p><div class="doc"><p>Each process is a pair of its destiny future-reference, and its (resumable) continuation</p><p>(note: is a newtype just for overriding its Show instance, check module <a href="PP.html">PP</a>)</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Proc" class="def">Proc</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:fromProc" class="def">fromProc</a> :: (<a href="Base.html#t:FutRef">FutRef</a>, <a href="Base.html#t:Cont">Cont</a>)</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:SchedQueue" class="def">SchedQueue</a> = Q <a href="Base.html#t:ObjRef">ObjRef</a> <a href="src/Base.html#SchedQueue" class="link">Source</a></p><div class="doc"><p>The global-system scheduler's runtime Process Table.</p><p>It is simply a queue of object-references</p></div></div><h1 id="g:3">Our language's AST and types</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Stmt" class="def">Stmt</a> <a href="src/Base.html#Stmt" class="link">Source</a></p><div class="doc"><p>An ABS statement.</p><p>Statements are &quot;chained&quot; (sequantially composed) by deeply nesting them through <code><a href="Base.html#t:Cont">Cont</a></code>inuations.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Assign" class="def">Assign</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> <a href="Base.html#t:Rhs">Rhs</a> <a href="Base.html#t:Cont">Cont</a></td><td class="doc"><p>&quot;attr&quot; := Rhs; cont...</p></td></tr><tr><td class="src"><a name="v:Await" class="def">Await</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> <a href="Base.html#t:Cont">Cont</a></td><td class="doc"><p>await &quot;attr&quot;; cont...</p></td></tr><tr><td class="src"><a name="v:If" class="def">If</a> <a href="Base.html#t:BExp">BExp</a> (<a href="Base.html#t:Cont">Cont</a> -&gt; <a href="Base.html#t:Stmt">Stmt</a>) (<a href="Base.html#t:Cont">Cont</a> -&gt; <a href="Base.html#t:Stmt">Stmt</a>) <a href="Base.html#t:Cont">Cont</a></td><td class="doc"><p>if pred ThenClause ElseClause; cont... </p></td></tr><tr><td class="src"><a name="v:While" class="def">While</a> <a href="Base.html#t:BExp">BExp</a> (<a href="Base.html#t:Cont">Cont</a> -&gt; <a href="Base.html#t:Stmt">Stmt</a>) <a href="Base.html#t:Cont">Cont</a></td><td class="doc"><p>while pred BodyClause; cont...</p></td></tr><tr><td class="src"><a name="v:Skip" class="def">Skip</a> <a href="Base.html#t:Cont">Cont</a></td><td class="doc"><p>skip; cont...</p></td></tr><tr><td class="src"><a name="v:Return" class="def">Return</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a>) <a href="Base.html#t:Cont">Cont</a></td><td class="doc"><p>return &quot;attr&quot; WriteBack; cont... (note: if it is a sync call then we pass as an argument to return, the attribute to write back to, if it is async call then we pass Nothing)</p></td></tr><tr><td class="src"><a name="v:GetBlocked" class="def">GetBlocked</a></td><td class="doc"><p>Dummy instruction to be returned by sched'</p></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Rhs" class="def">Rhs</a> <a href="src/Base.html#Rhs" class="link">Source</a></p><div class="doc"><p>the RHS of an assignment</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:New" class="def">New</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Get" class="def">Get</a> <a href="Base.html#t:FutRef">FutRef</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Async" class="def">Async</a> <a href="Base.html#t:ObjRef">ObjRef</a> <a href="Base.html#t:Method">Method</a> [<a href="Base.html#t:Ref">Ref</a>]</td><td class="doc"><p>obj-ref ! method([params])</p></td></tr><tr><td class="src"><a name="v:Sync" class="def">Sync</a> <a href="Base.html#t:Method">Method</a> [<a href="Base.html#t:Ref">Ref</a>]</td><td class="doc"><p>this.method([params])</p></td></tr><tr><td class="src"><a name="v:Val" class="def">Val</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:V" class="def">V</a> <a href="src/Base.html#V" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:I" class="def">I</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Add" class="def">Add</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Sub" class="def">Sub</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Prod" class="def">Prod</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Div" class="def">Div</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Mod" class="def">Mod</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Attr" class="def">Attr</a> <a href="Base.html#t:Ref">Ref</a></td><td class="doc"><p>dereference a given attribute by looking it up in this object's attribute-array</p></td></tr><tr><td class="src"><a name="v:Param" class="def">Param</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>do not dereference the given value, because it is method's parameter, thus passed-by-value. This is mainly used because all <code><a href="Base.html#t:Stmt">Stmt</a></code>s operate on attributes. A stmt `Assign &quot;attr&quot; (Param this)` would save the method's parameter to an attribute so it can be used elsewhere.</p></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:BExp" class="def">BExp</a> <a href="src/Base.html#BExp" class="link">Source</a></p><div class="doc"><p>A boolean expression occurs only as a control-flow predicate (if &amp; while) </p><p>It only references equality of attributes (<code><a href="Base.html#v:BEq">BEq</a></code>), combinators on them 
 (conjuction,disjunction,negation) and comparison between integer expressions</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:BEq" class="def">BEq</a> <a href="Base.html#t:Ref">Ref</a> <a href="Base.html#t:Ref">Ref</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:BNeg" class="def">BNeg</a> <a href="Base.html#t:BExp">BExp</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:BCon" class="def">BCon</a> <a href="Base.html#t:BExp">BExp</a> <a href="Base.html#t:BExp">BExp</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:BDis" class="def">BDis</a> <a href="Base.html#t:BExp">BExp</a> <a href="Base.html#t:BExp">BExp</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:IEq" class="def">IEq</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:INEq" class="def">INEq</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:IGT" class="def">IGT</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:IGTE" class="def">IGTE</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:ILT" class="def">ILT</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:ILTE" class="def">ILTE</a> <a href="Base.html#t:V">V</a> <a href="Base.html#t:V">V</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Method" class="def">Method</a> <a href="src/Base.html#Method" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">&nbsp;= [<a href="Base.html#t:Ref">Ref</a>]</td><td class="doc"><p>a list of passed (deref) parameters</p></td></tr><tr><td class="src">-&gt; <a href="Base.html#t:ObjRef">ObjRef</a></td><td class="doc"><p>this obj</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Base.html#t:Ref">Ref</a></td><td class="doc"><p>in case of sync call: a writeback attribute to write the return result to</p></td></tr><tr><td class="src">-&gt; <a href="Base.html#t:Cont">Cont</a></td><td class="doc"><p>the continuation after the method is finished</p></td></tr><tr><td class="src">-&gt; <a href="Base.html#t:Cont">Cont</a></td><td class="doc"><p>the resulting method's continuation that will start executing when applied to ()</p></td></tr></table></div><div class="doc"><p>The type of every top-level ABS-method.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>